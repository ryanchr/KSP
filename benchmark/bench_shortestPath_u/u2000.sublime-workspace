{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"sz",
				"size_t"
			],
			[
				"short",
				"shortest_path"
			],
			[
				"min",
				"min_bw"
			],
			[
				"cur_ed",
				"cur_edge_iter"
			],
			[
				"edge_",
				"edge_iterator"
			],
			[
				"edge_it",
				"edge_iter"
			],
			[
				"find",
				"find_out_edge_2id"
			],
			[
				"edge_iter",
				"edge_iterator"
			],
			[
				"pair",
				"pair_IntFlt"
			],
			[
				"sorte",
				"sorted_edges_of_vertex"
			],
			[
				"reset_",
				"reset_occurrence"
			],
			[
				"stack",
				"stack_nodes"
			],
			[
				"un",
				"unordered_set"
			],
			[
				"update",
				"updateReducedCost"
			],
			[
				"shor",
				"shorest_path"
			],
			[
				"sho",
				"shorest_path"
			],
			[
				"size",
				"size_t"
			],
			[
				"intern",
				"internel_src"
			],
			[
				"wirecon",
				"wireConStageNames"
			],
			[
				"sp",
				"split"
			],
			[
				"AG",
				"AGG_pair_num"
			],
			[
				"max_p",
				"max_phy_hops"
			],
			[
				"graph",
				"graphInit"
			],
			[
				"push",
				"push_back"
			],
			[
				"gra",
				"graph_t"
			]
		]
	},
	"buffers":
	[
		{
			"file": "sssp.cpp",
			"settings":
			{
				"buffer_size": 23580,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "/Users/renchen/gdrive/code/KSPfirst/openG/openG_graph.h",
			"settings":
			{
				"buffer_size": 17727,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/Users/renchen/gdrive/code/KSPfirst/openG/openG_property.h",
			"settings":
			{
				"buffer_size": 3631,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/Users/renchen/gdrive/code/KSPfirst/openG/openG_storage.h",
			"settings":
			{
				"buffer_size": 8447,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/Users/renchen/gdrive/code/KSPfirst/openG/openG.h",
			"settings":
			{
				"buffer_size": 27269,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Searching 1 file for \"top_ksp\" (regex)\n\n/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp.cpp:\n  162  \n  163  \n  164:     void output_shorest_path(graph_t& g, size_t src, size_t dest) //for test, src and dest is exID, dest is the input dest of top_ksp func.\n  165      {\n  166          cout<<\"the shortest path is: \";\n  ...\n  267  \n  268  \n  269: void top_ksp_subFun(bool trueMinCost, size_t trueMinCost_Iter, size_t& curr_kValue, ofstream& myfile,   \\\n  270  graph_t& g,  size_t src, size_t dest, size_t Kvalue, double max_phy_dist, size_t max_phy_hops,          \\\n  271  size_t min_phy_hops, size_t alpha, unordered_set<string>& paths) // src and dest are exID\n  ...\n  658   \n  659   \n  660: void top_ksp(size_t trueMinCost_Iter, ofstream& myfile, graph_t& g, size_t src, size_t dest,  \\\n  661  size_t Kvalue, double max_phy_dist, size_t max_phy_hops, size_t min_phy_hops, \n  662  gBenchPerf_event & perf, int perf_group )\n  ...\n  690  \n  691      // first operate trueMinCost with trueMinCost_Iter iterations\n  692:     //top_ksp_subFun(trueMinCost, trueMinCost_Iter, curr_kValue, myfile, g, src, dest, Kvalue, max_phy_dist, max_phy_hops, min_phy_hops, 1, paths);\n  693  \n  694      // second, find the remaining (Kvalue - curr_kValue) paths by using reduced hops\n  ...\n  699          trueMinCost = false;\n  700          alpha *= 8; //int(math.sqrt(rate));\n  701:         top_ksp_subFun(trueMinCost, trueMinCost_Iter, curr_kValue, myfile, g, src, dest, Kvalue, max_phy_dist, max_phy_hops, min_phy_hops, alpha, paths);\n  702      }\n  703      //myfile.close();\n  ...\n  848          \n  849          //res_fstream.open(\"./test_res/parallel_res_\"+to_string(idx), ofstream::trunc);\n  850:         top_ksp(true_min_iter, res_fstream, *graph, p_src , p_dest, k_val, max_phy_dist, max_phy_hops, min_phy_hops, perf, i);  \n  851          delete graph;\n  852      }\n  ...\n  879          graphInit(*graph, vfile, efile, src, dest, separator);\n  880  \n  881:         top_ksp(true_min_iter, res_fstream, *graph, p_src , p_dest, k_val, max_phy_dist, max_phy_hops, min_phy_hops, perf, 0);  \n  882          delete graph;\n  883  \n\n7 matches in 1 file\n\n\nSearching 1 file for \"_key2id\" (regex)\n\n/Users/renchen/gdrive/code/KSPfirst/openG/openG.h:\n   65      void add_vertex_key(uint64_t vid, std::string key)\n   66      {\n   67:         _key2id[key] = vid;\n   68          _id2key[vid] = key;\n   69      }\n   ..\n   75          if (it == _id2key.end()) return;\n   76  \n   77:         _key2id.erase(it->second);\n   78          _id2key.erase(it);\n   79      }\n   ..\n  176              }\n  177  \n  178:             std::string& key_str = _pos_buffer[keypos];  //// key part: key_str can be thought as external ID, while vit->id(), _key2id is a internal ID\n  179  \n  180              // add the vertex if not already present  // QS: if the input vertex.csv is with ID from 0,1,2   (alreay sorted), then internal ID is the same as external ID\n  181:             if (_key2id.find(key_str) == _key2id.end())\n  182              {\n  183                  vertex_iterator vit = this->add_vertex();\n  184:                 _key2id[key_str] = vit->id();\n  185                  _id2key[vit->id()] = key_str;\n  186              }\n  ...\n  276              }\n  277  \n  278:             std::string& key_str = _pos_buffer[keypos];  //// key part: key_str can be thought as external ID, while vit->id(), _key2id is a internal ID\n  279  \n  280              key_str = prefix_vid + key_str; // new, make id different at each layer\n  281  \n  282              // add the vertex if not already present  // QS: if the input vertex.csv is with ID from 0,1,2   (alreay sorted), then internal ID is the same as external ID\n  283:             if (_key2id.find(key_str) == _key2id.end())\n  284              {\n  285                  vertex_iterator vit = this->add_vertex();\n  286:                 _key2id[key_str] = vit->id();\n  287                  _id2key[vit->id()] = key_str;\n  288              }\n  ...\n  423  \n  424              std::tr1::unordered_map<std::string, uint64_t>::iterator srciter,destiter;\n  425:             srciter  = _key2id.find(src_str);\n  426:             destiter = _key2id.find(dest_str);\n  427  \n  428              // add the vertex if not already present\n  429:             if (srciter == _key2id.end())\n  430              {\n  431                  vertex_iterator vit = this->add_vertex();\n  432:                 _key2id[src_str] = vit->id();\n  433                  _id2key[vit->id()] = src_str;\n  434:                 srciter  = _key2id.find(src_str);\n  435              }\n  436:             if (destiter == _key2id.end())\n  437              {\n  438                  vertex_iterator vit = this->add_vertex();\n  439:                 _key2id[dest_str] = vit->id();\n  440                  _id2key[vit->id()] = dest_str;\n  441:                 destiter = _key2id.find(dest_str);\n  442              }\n  443  \n  ...\n  573  \n  574              std::tr1::unordered_map<std::string, uint64_t>::iterator srciter,destiter;\n  575:             srciter  = _key2id.find(src_str);\n  576:             destiter = _key2id.find(dest_str);\n  577  \n  578              // add the vertex if not already present\n  579:             if (srciter == _key2id.end())\n  580              {\n  581                  vertex_iterator vit = this->add_vertex();\n  582:                 _key2id[src_str] = vit->id();\n  583                  _id2key[vit->id()] = src_str;\n  584:                 srciter  = _key2id.find(src_str);\n  585              }\n  586:             if (destiter == _key2id.end())\n  587              {\n  588                  vertex_iterator vit = this->add_vertex();\n  589:                 _key2id[dest_str] = vit->id();\n  590                  _id2key[vit->id()] = dest_str;\n  591:                 destiter = _key2id.find(dest_str);\n  592              }\n  593  \n  ...\n  732      uint64_t external_to_internel_id(std::string exID) // new\n  733      {\n  734:         std::tr1::unordered_map<std::string, uint64_t>::iterator tmpIter = _key2id.find(exID);\n  735          return tmpIter->second;    \n  736      }\n  ...\n  743  \n  744  protected:\n  745:     std::tr1::unordered_map<std::string, uint64_t> _key2id;  // key: external id;  id: internel id\n  746      std::tr1::unordered_map<uint64_t, std::string> _id2key;\n  747  private:\n\n28 matches in 1 file\n\n\nSearching 1 file for \"adjacent_find\" (regex)\n\n/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp.cpp:\n  257      }\n  258      sort(path_id_set_g.begin(), path_id_set_g.end());\n  259:     return adjacent_find(path_id_set_g.begin(), path_id_set_g.end()) == path_id_set_g.end();\n  260  }\n  261  \n\n1 match in 1 file\n\n\nSearching 1 file for \"PQ\" (regex)\n\n/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp.cpp:\n  272  //calculate shortest path of a single source-dest pair\n  273  void sssp(bool trueMinCost, graph_t& g,  size_t src, size_t dest, size_t alpha, unordered_set<string>& paths\n  274:         ,priority_queue<pair_IntFlt, vector<pair_IntFlt>, min_comp_IntFlt> &PQ)\n  275  {\n  276      uint64_t internel_src  = g.external_to_internel_id(to_string(src)); \n  ...\n  287  \t//dest_vit->property().occurrence = dest_vit->property().occurrence;       // new\n  288  \t\n  289:     PQ.push(pair_IntFlt(internel_dest,0));\n  290  \n  291      // vit->property().successor is used to construct sssp, where the ancestor of all nodes is internel_dest, \n  292      // by using vit->property().successor recursively, we can find the shortest path of any node to internel_dest\n  293:     while (!PQ.empty())   // sum_distance  sum_hops\n  294      {\n  295:         size_t u = PQ.top().first; //id\n  296:         PQ.pop();\n  297  \n  298          vertex_iterator u_vit = g.find_vertex(u);\n  ...\n  312                      v_vit->property().sum_hops     = u_vit->property().sum_hops + 1; \n  313                      v_vit->property().sum_distance = u_vit->property().sum_distance + eit->property().phy_dist; \n  314:                     PQ.push(pair_IntFlt(v,alt));\n  315                  }\n  316              }\n  ...\n  334  \t\t\t\t\tv_vit->property().weight = weight;\n  335  \t\t\t\t\t\n  336:                     PQ.push(pair_IntFlt(v,weight));\n  337                  }\n  338              }\n  ...\n  389  \n  390      // only store the minCost and interenl ID of tau (the last id). \n  391:     priority_queue<pair_FltInt, vector<pair_FltInt>, min_comp_FltInt> PQ_KSP_candidates_tau; \n  392      vector<size_t> KSPaths_lastID_tau; // for output, store the top k shortest path id of tau.\n  393  \n  ...\n  407      src_vit_tau->property().min_cost += g.find_vertex( src_vit_tau->property().internel_id_of_g )->property().min_cost;\n  408  \tsrc_vit_tau->property().weight += g.find_vertex( src_vit_tau->property().internel_id_of_g )->property().weight;\n  409:     PQ_KSP_candidates_tau.push( pair_FltInt(src_vit_tau->property().weight, src_vit_tau->id()) );   //????\n  410      src_vit_tau->property().min_cost -= g.find_vertex( src_vit_tau->property().internel_id_of_g )->property().min_cost;\n  411  \tsrc_vit_tau->property().weight -= g.find_vertex( src_vit_tau->property().internel_id_of_g )->property().weight;\n  ...\n  424      size_t k = curr_kValue;\n  425      size_t iter = 0; \n  426:     while (k<Kvalue && !PQ_KSP_candidates_tau.empty() && iter<max_iter)\n  427      {\n  428          // find the current shortest path p (may have loop)\n  429:         size_t candi_last_id = PQ_KSP_candidates_tau.top().second; \n  430  \n  431          // X = X - {p}\n  432:         PQ_KSP_candidates_tau.pop();        \n  433  \n  434          // new\n  ...\n  590     \n  591                      dest_vit_tau->property().min_cost += g.find_vertex( dest_vit_tau->property().internel_id_of_g )->property().min_cost;\n  592:                     PQ_KSP_candidates_tau.push( pair_FltInt(dest_vit_tau->property().weight, dest_vit_tau->id()) );    //????\n  593                      dest_vit_tau->property().min_cost -= g.find_vertex( dest_vit_tau->property().internel_id_of_g )->property().min_cost;\n  594                      //dest_vit_tau->property().sum_distance -= vit_g->property().sum_distance;\n  ...\n  603          iter++;\n  604  \n  605:     } //while (k<Kvalue && !PQ_KSP_candidates_tau.empty() && iter<max_iter)\n  606      curr_kValue = k;\n  607  \n  608      cout<<\"Output: trueMinCost is \"<< trueMinCost <<endl;;\n  609:     cout<<\"--the running iteration (do PQ pop) is \"<<iter<<endl;\n  610      cout<<\"--the found final path number is \"<<KSPaths_lastID_tau.size()<<endl;\n  611  \n\n15 matches in 1 file\n\n\nSearching 1 file for \"PQ\" (regex, whole word)\n\n<untitled 687>:\n    ERROR: Unable to open file\n\n0 matches\n\nSearching 1 file for \"PQ\" (regex)\n\n<untitled 687>:\n    ERROR: Unable to open file\n\n0 matches\n\nSearching 1 file for \"PQ\" (regex)\n\n<untitled 687>:\n    ERROR: Unable to open file\n\n0 matches\n\nSearching 1 file for \"PQ\" (regex)\n\n/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp.cpp:\n  272  //calculate shortest path of a single source-dest pair\n  273  void sssp(bool trueMinCost, graph_t& g,  size_t src, size_t dest, size_t alpha, unordered_set<string>& paths\n  274:         ,priority_queue<pair_IntFlt, vector<pair_IntFlt>, min_comp_IntFlt> &PQ)\n  275  {\n  276      uint64_t internel_src  = g.external_to_internel_id(to_string(src)); \n  ...\n  287  \t//dest_vit->property().occurrence = dest_vit->property().occurrence;       // new\n  288  \t\n  289:     PQ.push(pair_IntFlt(internel_dest,0));\n  290  \n  291      // vit->property().successor is used to construct sssp, where the ancestor of all nodes is internel_dest, \n  292      // by using vit->property().successor recursively, we can find the shortest path of any node to internel_dest\n  293:     while (!PQ.empty())   // sum_distance  sum_hops\n  294      {\n  295:         size_t u = PQ.top().first; //id\n  296:         PQ.pop();\n  297  \n  298          vertex_iterator u_vit = g.find_vertex(u);\n  ...\n  312                      v_vit->property().sum_hops     = u_vit->property().sum_hops + 1; \n  313                      v_vit->property().sum_distance = u_vit->property().sum_distance + eit->property().phy_dist; \n  314:                     PQ.push(pair_IntFlt(v,alt));\n  315                  }\n  316              }\n  ...\n  334  \t\t\t\t\tv_vit->property().weight = weight;\n  335  \t\t\t\t\t\n  336:                     PQ.push(pair_IntFlt(v,weight));\n  337                  }\n  338              }\n  ...\n  389  \n  390      // only store the minCost and interenl ID of tau (the last id). \n  391:     priority_queue<pair_FltInt, vector<pair_FltInt>, min_comp_FltInt> PQ_KSP_candidates_tau; \n  392      vector<size_t> KSPaths_lastID_tau; // for output, store the top k shortest path id of tau.\n  393  \n  ...\n  407      src_vit_tau->property().min_cost += g.find_vertex( src_vit_tau->property().internel_id_of_g )->property().min_cost;\n  408  \tsrc_vit_tau->property().weight += g.find_vertex( src_vit_tau->property().internel_id_of_g )->property().weight;\n  409:     PQ_KSP_candidates_tau.push( pair_FltInt(src_vit_tau->property().weight, src_vit_tau->id()) );   //????\n  410      src_vit_tau->property().min_cost -= g.find_vertex( src_vit_tau->property().internel_id_of_g )->property().min_cost;\n  411  \tsrc_vit_tau->property().weight -= g.find_vertex( src_vit_tau->property().internel_id_of_g )->property().weight;\n  ...\n  424      size_t k = curr_kValue;\n  425      size_t iter = 0; \n  426:     while (k<Kvalue && !PQ_KSP_candidates_tau.empty() && iter<max_iter)\n  427      {\n  428          // find the current shortest path p (may have loop)\n  429:         size_t candi_last_id = PQ_KSP_candidates_tau.top().second; \n  430  \n  431          // X = X - {p}\n  432:         PQ_KSP_candidates_tau.pop();        \n  433  \n  434          // new\n  ...\n  590     \n  591                      dest_vit_tau->property().min_cost += g.find_vertex( dest_vit_tau->property().internel_id_of_g )->property().min_cost;\n  592:                     PQ_KSP_candidates_tau.push( pair_FltInt(dest_vit_tau->property().weight, dest_vit_tau->id()) );    //????\n  593                      dest_vit_tau->property().min_cost -= g.find_vertex( dest_vit_tau->property().internel_id_of_g )->property().min_cost;\n  594                      //dest_vit_tau->property().sum_distance -= vit_g->property().sum_distance;\n  ...\n  603          iter++;\n  604  \n  605:     } //while (k<Kvalue && !PQ_KSP_candidates_tau.empty() && iter<max_iter)\n  606      curr_kValue = k;\n  607  \n  608      cout<<\"Output: trueMinCost is \"<< trueMinCost <<endl;;\n  609:     cout<<\"--the running iteration (do PQ pop) is \"<<iter<<endl;\n  610      cout<<\"--the found final path number is \"<<KSPaths_lastID_tau.size()<<endl;\n  611  \n\n15 matches in 1 file\n\n\nSearching 1 file for \"unordered_set\" (regex)\n\n/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp.cpp:\n   18  #include <stack>\n   19  #include <cstdlib>\n   20: #include <unordered_set>\n   21  \n   22  using namespace std;\n   ..\n  265  void spmc_subFun(bool trueMinCost, size_t trueMinCost_Iter, size_t& curr_kValue, ofstream& myfile,   \\\n  266  graph_t& g,  size_t src, size_t dest, size_t Kvalue, double max_phy_dist, size_t max_phy_hops,          \\\n  267: size_t min_phy_hops, size_t alpha, unordered_set<string>& paths) // src and dest are exID\n  268  {\n  269  \n  ...\n  271  \n  272  //calculate shortest path of a single source-dest pair\n  273: void sssp(bool trueMinCost, graph_t& g,  size_t src, size_t dest, size_t alpha, unordered_set<string>& sp_nodes)\n  274  {\n  275      uint64_t internel_src  = g.external_to_internel_id(to_string(src)); \n  ...\n  377  \n  378  //find backup path\n  379: void findBackupPath(bool trueMinCost, graph_t& g, size_t src, size_t dest, size_t alpha, unordered_set<uint64_t>& visited_nodes)\n  380  {\n  381      stack<uint64_t> nodes;\n  ...\n  543              vector<uint64_t> neighborNodes_tau; \n  544              // vector<uint64_t> neighborNodes_tau_at_g; //ori: \n  545:             unordered_set<uint64_t> neighborNodes_tau_at_g; // to speed up the find operation later\n  546              tau.find_vertex_out_neighborNodes(pk_top_id, neighborNodes_tau); // here only need  out neigbor, the\n  547              for (size_t idx=0; idx<neighborNodes_tau.size(); ++idx)\n  ...\n  567              for (size_t idx=0; idx<neighborNodes_g.size(); ++idx)\n  568              {\n  569:                 //if ( !(find(neighborNodes_tau_at_g.begin(), neighborNodes_tau_at_g.end(), neighborNodes_g[idx].first) != neighborNodes_tau_at_g.end()) ) // try unordered_set\n  570                  if (  neighborNodes_tau_at_g.find(neighborNodes_g[idx].first) == neighborNodes_tau_at_g.end()  ) // --> similar or even slow in small cases.\n  571                  {\n  ...\n  709      bool trueMinCost        = true;\n  710      size_t curr_kValue      = 0;\n  711:     unordered_set<string> paths;\n  712  \n  713      // first operate trueMinCost with trueMinCost_Iter iterations\n\n7 matches in 1 file\n\n\nSearching 1 file for \"paths\" (regex)\n\n/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp.cpp:\n   95  {\n   96  public:    \n   97:     vertex_property_tau():at_KSPaths(false),predecessor(MY_INFINITY),internel_id_of_g(MY_INFINITY)  \\\n   98                           ,min_cost(0),sum_distance(0),sum_hops(0),weight(0),occurrence(0){}\n   99  \n  100:     bool at_KSPaths;             //vector<size_t> KSPaths_record;\n  101      uint64_t predecessor;        // for shortest path, store the id of the graph tau\n  102      uint64_t internel_id_of_g;   // internel id of orginal graph g\n  ...\n  212          // add point and edge at tau\n  213          dest_vit_tau = tau.add_vertex();\n  214:         dest_vit_tau->property().at_KSPaths = false;// \n  215          dest_vit_tau->property().predecessor = tau_tmp_id; // \n  216          dest_vit_tau->property().internel_id_of_g = dest_vit_g->id();   \n  ...\n  265  void spmc_subFun(bool trueMinCost, size_t trueMinCost_Iter, size_t& curr_kValue, ofstream& myfile,   \\\n  266  graph_t& g,  size_t src, size_t dest, size_t Kvalue, double max_phy_dist, size_t max_phy_hops,          \\\n  267: size_t min_phy_hops, size_t alpha, unordered_set<string>& paths) // src and dest are exID\n  268  {\n  269  \n  ...\n  395      // only store the minCost and interenl ID of tau (the last id). \n  396      priority_queue<pair_FltInt, vector<pair_FltInt>, min_comp_FltInt> PQ_KSP_candidates_tau; \n  397:     vector<size_t> KSPaths_lastID_tau; // for output, store the top k shortest path id of tau.\n  398  \n  399      // add the internel_src as the first node in tau\n  400      vertex_iterator_tau src_vit_tau = tau.add_vertex();\n  401:     src_vit_tau->property().at_KSPaths = false;//src_vit_tau->property().KSPaths_record.push_back(1); // this node is at the 1st shortest path.\n  402      src_vit_tau->property().internel_id_of_g = internel_src; // this is internel_src\n  403      src_vit_tau->property().predecessor = MY_INFINITY;\n  ...\n  485  \t\t\t} while (candi_id_tau != internel_src_tau);\n  486  \t\t\t\n  487: \t\t\tif (paths.find(key) == paths.end() and !overused)\n  488  \t\t\t{\n  489: \t\t\t\tKSPaths_lastID_tau.push_back(candi_last_id);\n  490  \t\t\t\tk++;\n  491  \t\t\t\t//insert a new key\n  492: \t\t\t\tpaths.insert(key);\n  493  \t\t\t\tvector<vertex_iterator>::iterator v_iter;\n  494  \t\t\t\t//update occurrence of each vertex\n  ...\n  503          // find the deviation path pk_vkt_nodes, the top of pk_vkt_nodes is the deviation node\n  504          stack<size_t> pk_vkt_nodes;\n  505:         size_t tmp_id = candi_last_id; // KSPaths_lastID_tau.back()\n  506          vertex_iterator_tau dest_vit_tau = tau.find_vertex(tmp_id);\n  507:         dest_vit_tau->property().at_KSPaths = true;  \n  508          while (tmp_id != internel_src_tau)  \n  509          {\n  ...\n  512              pk_vkt_nodes.push(tmp_id);\n  513              dest_vit_tau = tau.find_vertex(tmp_id);\n  514:             if (dest_vit_tau->property().at_KSPaths == true) \n  515              {\n  516                  break;\n  517              }\n  518:             dest_vit_tau->property().at_KSPaths = true;  \n  519          }\n  520  \n  ...\n  540  \n  541              // (new version )find A_Tk_(v),  now further update it that  A_Tk_(v) contains out edges (sucsessors) and all predecessors up to internel_src_tau\n  542:             // this update is to reduce the number of loop paths\n  543              vector<uint64_t> neighborNodes_tau; \n  544              // vector<uint64_t> neighborNodes_tau_at_g; //ori: \n  ...\n  579                      assert(find_result);\n  580  \n  581:                     dest_vit_tau->property().at_KSPaths = false;//dest_vit_tau->property().KSPaths_record.push_back(1); // this node is at the 1st shortest path.\n  582                      dest_vit_tau->property().predecessor = pk_top_id; // pk_top_id = pk_vkt_nodes.top();\n  583                      dest_vit_tau->property().internel_id_of_g = neighborNodes_g[idx].first;   \n  ...\n  613      cout<<\"Output: trueMinCost is \"<< trueMinCost <<endl;;\n  614      cout<<\"--the running iteration (do PQ pop) is \"<<iter<<endl;\n  615:     cout<<\"--the found final path number is \"<<KSPaths_lastID_tau.size()<<endl;\n  616  \n  617:     /*if (KSPaths_lastID_tau.size()==0)\n  618      {\n  619          cout<<\"cannot find any path, maybe we have too much constraints!\"<<endl;\n  ...\n  622      }*/\n  623  \n  624:     for (size_t idx = 0; idx < KSPaths_lastID_tau.size(); ++idx)\n  625      {\n  626          //size_t tmp_k = idx + 1;\n  627:         uint64_t curr_id_tau = KSPaths_lastID_tau[idx];\n  628  \n  629          vertex_iterator_tau vit_tau = tau.find_vertex(curr_id_tau);\n  ...\n  657          myfile<<\",\\n\";\n  658  \n  659:         if ( !is_loopless_path(g, tau, KSPaths_lastID_tau[idx], internel_src_tau) )\n  660          {\n  661              cout<<endl<<\"wrong, this path has loop\"<<endl;\n  ...\n  666  \n  667      /*\n  668:     if (Kvalue!=KSPaths_lastID_tau.size())\n  669      {\n  670:         cout<<\"Warning: the input k= \"<<Kvalue<<\" is too large, cannot find the required loopless paths with current constraints!\"<<endl;\n  671:         cout<<\"the largest possible k is \"<<KSPaths_lastID_tau.size()<<endl;\n  672      }\n  673      */\n  ...\n  709      bool trueMinCost        = true;\n  710      size_t curr_kValue      = 0;\n  711:     unordered_set<string> paths;\n  712  \n  713      // first operate trueMinCost with trueMinCost_Iter iterations\n  714:     //spmc_subFun(trueMinCost, trueMinCost_Iter, curr_kValue, myfile, g, src, dest, Kvalue, max_phy_dist, max_phy_hops, min_phy_hops, 1, paths);\n  715  \n  716:     // second, find the remaining (Kvalue - curr_kValue) paths by using reduced hops\n  717      int alpha = 1;\n  718      while (curr_kValue < Kvalue)\n  ...\n  721          trueMinCost = false;\n  722          alpha *= 8; //int(math.sqrt(rate));\n  723:         spmc_subFun(trueMinCost, trueMinCost_Iter, curr_kValue, myfile, g, src, dest, Kvalue, max_phy_dist, max_phy_hops, min_phy_hops, alpha, paths);\n  724      }\n  725      //myfile.close();\n\n31 matches in 1 file\n\n\nSearching 1 file for \"sorted_edges_of_vertex\" (regex)\n\n/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp.cpp:\n   52  \tuint64_t occurrence;            // new\n   53  \t\n   54:     vector<pair_IntFlt> sorted_edges_of_vertex;  // pair: id (outedge), reduced_cost\n   55  };\n   56  \n   ..\n   82  \t\tvit->property().weight       = FLT_MAX;\n   83  \t\tvit->property().occurrence   = 0;\n   84:         vit->property().sorted_edges_of_vertex.clear();\n   85  \n   86          for (edge_iterator eit = vit->in_edges_begin(); eit != vit->in_edges_end(); eit++)  // new for in edge\n   ..\n  368              }\n  369              eit->property().reduced_cost = reduced_cost;\n  370:             u_vit->property().sorted_edges_of_vertex.push_back(pair_IntFlt(v,reduced_cost));     // pair: id (outedge), reduced_cost\n  371          }\n  372:         sort(u_vit->property().sorted_edges_of_vertex.begin(), u_vit->property().sorted_edges_of_vertex.end(),\n  373              [](pair_IntFlt vecInput_1, pair_IntFlt vecInput_2) {return (vecInput_1.second < vecInput_2.second);} );\n  374      }\n  ...\n  542              size_t cur_deviation_id_g = pk_top_vit->property().internel_id_of_g;  // cur_deviation_id_g is the v in MPS\n  543              vertex_iterator tmp_vit = g.find_vertex(cur_deviation_id_g);        \n  544:             vector<pair_IntFlt> neighborNodes_g = tmp_vit->property().sorted_edges_of_vertex;\n  545  \n  546  \n\n6 matches in 1 file\n\n\nSearching 1 file for \"pair_IntFlt\" (regex)\n\n/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp.cpp:\n   36  size_t enditer = 0;\n   37  \n   38: typedef pair<size_t,float> pair_IntFlt; //  //typedef pair<size_t,size_t> pair_IntFlt; //\n   39: typedef pair<float,size_t> pair_FltInt; //  //typedef pair<size_t,size_t> pair_IntFlt; //\n   40: typedef pair<size_t,size_t> pair_IntInt; //  //typedef pair<size_t,size_t> pair_IntFlt; //\n   41  \n   42  class vertex_property // new\n   ..\n   52  \tuint64_t occurrence;            // new\n   53  \t\n   54:     vector<pair_IntFlt> sorted_edges_of_vertex;  // pair: id (outedge), reduced_cost\n   55  };\n   56  \n   ..\n  126  {\n  127  public:\n  128:     bool operator()(pair_IntFlt a, pair_IntFlt b)\n  129      {\n  130          return a.second > b.second;\n  ...\n  275      uint64_t internel_src  = g.external_to_internel_id(to_string(src)); \n  276      uint64_t internel_dest = g.external_to_internel_id(to_string(dest)); \n  277:     priority_queue<pair_IntFlt, vector<pair_IntFlt>, min_comp_IntFlt> PQ\n  278  \n  279      //// Now all processing is based on internel id first.\n  ...\n  286  \t//dest_vit->property().occurrence = dest_vit->property().occurrence;       // new\n  287  \t\n  288:     PQ.push(pair_IntFlt(internel_dest,0));\n  289  \n  290      // vit->property().successor is used to construct sssp, where the ancestor of all nodes is internel_dest, \n  ...\n  311                      v_vit->property().sum_hops     = u_vit->property().sum_hops + 1; \n  312                      v_vit->property().sum_distance = u_vit->property().sum_distance + eit->property().phy_dist; \n  313:                     PQ.push(pair_IntFlt(v,alt));\n  314                  }\n  315              }\n  ...\n  333  \t\t\t\t\tv_vit->property().weight = weight;\n  334  \t\t\t\t\t\n  335:                     PQ.push(pair_IntFlt(v,weight));\n  336                  }\n  337              }\n  ...\n  368              }\n  369              eit->property().reduced_cost = reduced_cost;\n  370:             u_vit->property().sorted_edges_of_vertex.push_back(pair_IntFlt(v,reduced_cost));     // pair: id (outedge), reduced_cost\n  371          }\n  372          sort(u_vit->property().sorted_edges_of_vertex.begin(), u_vit->property().sorted_edges_of_vertex.end(),\n  373:             [](pair_IntFlt vecInput_1, pair_IntFlt vecInput_2) {return (vecInput_1.second < vecInput_2.second);} );\n  374      }\n  375  }\n  ...\n  386          size_t cur_node = nodes.pop()\n  387          vertex_iterator cur_vit = g.find_vertex(cur_node)\n  388:         vector<pair_IntFlt> & sorted_edges = cur_vit->property().sorted_edges_of_vertex\n  389  \n  390          for(auto vit = sorted_edges.begin(); vit != sorted_edges.end(); ++vit)\n  ...\n  547              size_t cur_deviation_id_g = pk_top_vit->property().internel_id_of_g;  // cur_deviation_id_g is the v in MPS\n  548              vertex_iterator tmp_vit = g.find_vertex(cur_deviation_id_g);        \n  549:             vector<pair_IntFlt> neighborNodes_g = tmp_vit->property().sorted_edges_of_vertex;\n  550  \n  551  \n\n17 matches in 1 file\n\n\nSearching 1 file for \"is_loopless_path\" (regex)\n\n/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp.cpp:\n  245  \n  246  //Can be optimized using an unordered map\n  247: bool is_loopless_path(graph_t& g, graph_tau& tau, size_t path_last_id_tau, size_t path_first_id_tau)//based on sorted vector\n  248  {\n  249      size_t tmpId = path_last_id_tau;    \n  ...\n  484  \n  485          within_max_phy_dist = true; //Note!!!  for single-layer since no dist in this case.\n  486:         if ( is_valid_candidate && within_max_phy_dist && within_max_phy_hops && largerthan_min_phy_hops && is_loopless_path(g, tau, candi_last_id, internel_src_tau) )  \n  487          {\n  488  \t\t\t//Obtain the key for the path\n  ...\n  559  \n  560              // get out if there is loop to save time\n  561:             if ( !is_loopless_path(g, tau, pk_top_id, internel_src_tau) )\n  562              {\n  563                  break;\n  ...\n  689          myfile<<\",\\n\";\n  690  \n  691:         if ( !is_loopless_path(g, tau, KSPaths_lastID_tau[idx], internel_src_tau) )\n  692          {\n  693              cout<<endl<<\"wrong, this path has loop\"<<endl;\n\n4 matches in 1 file\n\n\nSearching 1 file for \"is_loopless_path\" (regex)\n\n/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp.cpp:\n  245  \n  246  //Can be optimized using an unordered map\n  247: bool is_loopless_path(graph_t& g, graph_tau& tau, size_t path_last_id_tau, size_t path_first_id_tau)//based on sorted vector\n  248  {\n  249      size_t tmpId = path_last_id_tau;    \n\n1 match in 1 file\n\n\nSearching 1 file for \"add_partialSP_totau\" (regex)\n\n/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp.cpp:\n  184  \n  185  \n  186: vertex_iterator_tau add_partialSP_totau(graph_t& g, size_t src_id_g, size_t dest_id_g, graph_tau& tau, size_t start_id_tau,   \\\n  187  double max_phy_dist, size_t max_phy_hops, size_t alpha)  \n  188  {\n\n1 match in 1 file\n\n\nSearching 1 file for \"reset_graph\" (regex)\n\n/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp.cpp:\n   71  \n   72  \n   73: void reset_graph(graph_t & g)\n   74  {\n   75      vertex_iterator vit;\n   ..\n  364      while (!find_path and alpha < max_alpha)\n  365      {\n  366:         reset_graph(g);\n  367          alpha *= 8; //int(math.sqrt(rate));\n  368          spmcSub(myfile, g, src, dest, alpha, find_path);\n\n2 matches in 1 file\n\n\nSearching 1 file for \"occurrence\" (regex)\n\n/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp.cpp:\n   43  {\n   44  public:  // sum_distance(0),sum_hops(0){}\n   45:     vertex_property():min_cost(FLT_MAX),successor(MY_INFINITY),sum_distance(FLT_MAX),sum_hops(MY_INFINITY),weight(FLT_MAX),occurrence(0){}\n   46      float min_cost;                 // for shortest path\n   47      // predecessor;                 // for shortest path successor,\n   ..\n   50      uint64_t sum_hops;              // new \n   51  \tfloat weight;                   // new\n   52: \tuint64_t occurrence;            // new\n   53  \t\n   54      vector<pair_IntFlt> sorted_edges_of_vertex;  // pair: id (outedge), reduced_cost\n   ..\n   81          vit->property().sum_hops     = MY_INFINITY;\n   82  \t\tvit->property().weight       = FLT_MAX;\n   83: \t\tvit->property().occurrence   = 0;\n   84          vit->property().sorted_edges_of_vertex.clear();\n   85  \n   ..\n  184      dest_vit->property().sum_distance = 0; // new\n  185  \tdest_vit->property().weight = 0;       // new\n  186: \t//dest_vit->property().occurrence = dest_vit->property().occurrence;       // new\n  187  \t\n  188      PQ.push(pair_IntFlt(internel_dest,0));\n  ...\n  205              unsigned int alt = u_vit->property().sum_hops + 1; // \n  206  \t\t\tfloat alt_cost = u_vit->property().min_cost + eit->property().cost; //  \n  207: \t\t\tunsigned int occur = v_vit->property().occurrence;\n  208  \t\t\t\n  209  \t\t\tunsigned int alpha_occur = (occur > 7000) ? int(alpha*10) : int(alpha*10);\n  ...\n  261              //reduced_cost = v_vit->property().sum_hops - u_vit->property().sum_hops + 1;  // min_cost  -- sum_hops    exchange\n  262  \t\t\tunsigned int hops_gap  = v_vit->property().sum_hops - u_vit->property().sum_hops + 1; \n  263: \t\t\t//generalized reduced_cost = edge_weight + edge_cost/alpha + alpha*(num_hops=1) + dest_v.occurrence *(alpha*10.0)\n  264  \t\t\t\n  265: \t\t\tunsigned int alpha_occur = (v_vit->property().occurrence > 7000) ? int(alpha*10.0) : int(alpha*10.0);\n  266: \t\t\treduced_cost = v_vit->property().min_cost - u_vit->property().min_cost + eit->property().cost + v_vi->property().occurrence*alpha_occur; \n  267              \n  268              eit->property().reduced_cost = reduced_cost;\n  ...\n  298          if (visited_nodes.find(tmp_node) != visited_nodes.end())\n  299              vertex_iterator v_tmp_node = g.find_vertex(tmp_node);\n  300:             v_tmp_node->property().occurrence += 1;\n  301              no_share_nodes = 0;\n  302              break;\n\n10 matches in 1 file\n\n\nSearching 1 file for \"auto\" (regex)\n\n/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp.cpp:\n  116      void displayVectorOrListContents(const T& input)\n  117      {\n  118:         for (auto idx = input.cbegin(); idx != input.cend(); ++ idx)\n  119          {\n  120              cout << *idx << \",\";\n  ...\n  125      void displayVectorOrListOfPairContents(const T& input)  \n  126      {\n  127:         for (auto idx = input.cbegin(); idx != input.cend(); ++ idx)\n  128          {\n  129              cout << \"(\" << idx->first << \",\" << idx->second << \")\" << \",\";\n  ...\n  313      vertex_iterator cur_vit = g.find_vertex(cur_node)\n  314      vector<pair_IntFlt> & sorted_edges = cur_vit->property().sorted_edges_of_vertex\n  315:     for(auto v_cost_pair = sorted_edges.begin(); v_cost_pair != sorted_edges.end(); ++v_cost_pair)\n  316      {\n  317          if (visited_nodes.find(v_cost_pair.first) == visited_nodes.end())\n  ...\n  360      \n  361      //\n  362:     for (auto src_iter = )\n  363      bool find_path = 0;\n  364      int alpha = 1;\n\n4 matches in 1 file\n\n\nSearching 1 file for \"cost\" (regex)\n\n/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp.cpp:\n   43  {\n   44  public:  // sum_distance(0),sum_hops(0){}\n   45:     vertex_property():min_cost(FLT_MAX),successor(MY_INFINITY),sum_distance(FLT_MAX),sum_hops(MY_INFINITY)  \\\n   46      ,weight(FLT_MAX),occurrence(0){}\n   47:     float min_cost;                 // for shortest path\n   48      // predecessor;                 // for shortest path successor,\n   49      uint64_t successor;             // for shortest path \n   ..\n   53  \tuint64_t occurrence;            // new\n   54  \t\n   55:     vector<pair_IntFlt> sorted_edges_of_vertex;  // pair: id (outedge), reduced_cost\n   56  };\n   57  \n   ..\n   59  {\n   60  public:\n   61:     edge_property():cost(FLT_MAX),phy_dist(FLT_MAX),reduced_cost(FLT_MAX){} // new:  Note: \n   62  \n   63:     float cost; // note: here cost means cost\n   64      float phy_dist; //new\n   65      float bw;\n   66  \n   67:     float reduced_cost; //  \n   68  };\n   69  \n   ..\n   78      for (vit=g.vertices_begin(); vit!=g.vertices_end(); vit++)\n   79      {\n   80:         vit->property().min_cost     = FLT_MAX;\n   81          vit->property().successor    = MY_INFINITY;\n   82          vit->property().sum_distance = FLT_MAX;\n   ..\n   89          for (edge_iterator eit = vit->in_edges_begin(); eit != vit->in_edges_end(); eit++)  // new for in edge\n   90          {\n   91:             eit->property().reduced_cost = FLT_MAX;\n   92          }\n   93      }\n   ..\n  181  \n  182      //// Now all processing is based on internel id first.\n  183:     //// (1) sssp sub-procedure  -->for vertex: update  v_vit->property().min_cost and v_vit->property().successor \n  184      vertex_iterator dest_vit = g.find_vertex(internel_dest);  // note: here the source of sssp is internel_dest, \n  185:     dest_vit->property().min_cost = 0;\n  186      dest_vit->property().sum_hops = 0;     // new\n  187      dest_vit->property().sum_distance = 0; // new\n  ...\n  205  \n  206              // for every  vertex, try relaxing the path\n  207:             // min_cost  -- sum_hops    exchange\n  208              unsigned int alt = u_vit->property().sum_hops + 1; // \n  209: \t\t\tfloat alt_cost = u_vit->property().min_cost + eit->property().cost; //  \n  210  \t\t\tunsigned int occur = v_vit->property().occurrence;\n  211  \t\t\t\n  212  \t\t\tunsigned int alpha_occur = (occur > 7000) ? int(alpha*10) : int(alpha*10);\n  213: \t\t\tunsigned int weight = alt*alpha + alt_cost + occur*alpha_occur;\n  214  \t\t\t\n  215              //if (alt < v_vit->property().sum_hops) \n  ...\n  218                  v_vit->property().successor = u;  // new, ori is predecessor\n  219                  v_vit->property().sum_hops     = alt; \n  220:                 v_vit->property().min_cost     = u_vit->property().min_cost + eit->property().cost; \n  221                  v_vit->property().sum_distance = u_vit->property().sum_distance + eit->property().phy_dist; \n  222  \t\t\t\tv_vit->property().weight = weight;\n  ...\n  229  \n  230  \n  231: ////(2) reduced_cost computing procedure  -->for edge: update eit->property().reduced_cost\n  232  ////(3) rearrange the arcs\n  233: void updateReducedCost(graph_t& g, size_t alpha)\n  234  {\n  235      for (vertex_iterator u_vit=g.vertices_begin(); u_vit!=g.vertices_end(); u_vit++) // for each vertex u\n  ...\n  240              vertex_iterator v_vit = g.find_vertex(v);\n  241  \n  242:             float reduced_cost;\n  243              \n  244:             //reduced_cost = v_vit->property().sum_hops - u_vit->property().sum_hops + 1;  // min_cost  -- sum_hops    exchange\n  245  \t\t\tunsigned int hops_gap  = v_vit->property().sum_hops - u_vit->property().sum_hops + 1; \n  246: \t\t\t//generalized reduced_cost = edge_weight + edge_cost/alpha + alpha*(num_hops=1) + dest_v.occurrence *(alpha*10.0)\n  247  \t\t\t\n  248  \t\t\tunsigned int alpha_occur = (v_vit->property().occurrence > 7000) ? int(alpha*10.0) : int(alpha*10.0);\n  249: \t\t\treduced_cost = v_vit->property().min_cost - u_vit->property().min_cost + eit->property().cost + v_vi->property().occurrence*alpha_occur; \n  250              \n  251:             eit->property().reduced_cost = reduced_cost;\n  252:             u_vit->property().sorted_edges_of_vertex.push_back(pair_IntFlt(v,reduced_cost));     // pair: id (outedge), reduced_cost\n  253          }\n  254          sort(u_vit->property().sorted_edges_of_vertex.begin(), u_vit->property().sorted_edges_of_vertex.end(),\n  ...\n  315      vertex_iterator cur_vit = g.find_vertex(cur_node)\n  316      vector<pair_IntFlt> & sorted_edges = cur_vit->property().sorted_edges_of_vertex\n  317:     for(auto v_cost_pair = sorted_edges.begin(); v_cost_pair != sorted_edges.end(); ++v_cost_pair)\n  318      {\n  319:         if (visited_nodes.find(v_cost_pair.first) == visited_nodes.end())\n  320          {\n  321:             stack_nodes.push(v_cost_pair.first)\n  322              backTrackingSearch(g, visited_nodes, src, dest, stack_nodes, findPath)\n  323              if findPath\n  ...\n  337          sssp(g, src, dest, alpha)\n  338  \n  339:     //Compute reduced cost\n  340      if (recompute_g)\n  341:         updateReducedCost(g, alpha)\n  342  \n  343      //Find shortest path\n\n44 matches in 1 file\n\n\nSearching 1 file for \"cost\" (regex, whole word)\n\n/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp.cpp:\n   59  {\n   60  public:\n   61:     edge_property():cost(FLT_MAX),phy_dist(FLT_MAX),reduced_cost(FLT_MAX){} // new:  Note: \n   62  \n   63:     float cost; // note: here cost means cost\n   64      float phy_dist; //new\n   65      float bw;\n   ..\n  207              // min_cost  -- sum_hops    exchange\n  208              unsigned int alt = u_vit->property().sum_hops + 1; // \n  209: \t\t\tfloat alt_cost = u_vit->property().min_cost + eit->property().cost; //  \n  210  \t\t\tunsigned int occur = v_vit->property().occurrence;\n  211  \t\t\t\n  ...\n  218                  v_vit->property().successor = u;  // new, ori is predecessor\n  219                  v_vit->property().sum_hops     = alt; \n  220:                 v_vit->property().min_cost     = u_vit->property().min_cost + eit->property().cost; \n  221                  v_vit->property().sum_distance = u_vit->property().sum_distance + eit->property().phy_dist; \n  222  \t\t\t\tv_vit->property().weight = weight;\n  ...\n  247  \t\t\t\n  248  \t\t\tunsigned int alpha_occur = (v_vit->property().occurrence > 7000) ? int(alpha*10.0) : int(alpha*10.0);\n  249: \t\t\treduced_cost = v_vit->property().min_cost - u_vit->property().min_cost + eit->property().cost + v_vi->property().occurrence*alpha_occur; \n  250              \n  251              eit->property().reduced_cost = reduced_cost;\n  ...\n  337          sssp(g, src, dest, alpha)\n  338  \n  339:     //Compute reduced cost\n  340      if (recompute_g)\n  341          updateReducedCost(g, alpha)\n\n8 matches in 1 file\n\n\nSearching 1 file for \"phy_dist\" (regex, whole word)\n\n/Users/renchen/gdrive/code/KSPfirst/openG/openG.h:\n  459              if (phy_distpos > 0) //new with #define EDGE_WEIGHT  // new\n  460              {\n  461:                 eit->property().phy_dist = atof(_pos_buffer[phy_distpos].c_str());  // atof\n  462              }            \n  463  //#endif\n\n1 match in 1 file\n\n\nSearching 1 file for \"costpos\" (regex, whole word)\n\n/Users/renchen/gdrive/code/KSPfirst/openG/openG.h:\n  319      //===================================================================//\n  320      long int load_csv_edges(std::string filename, bool has_header, std::string separators,\n  321:                             size_t srcpos, size_t destpos, bool dag_check=false, bool * loop_ctrl=NULL, int costpos=2, int phy_distpos=3) //int costpos=-1\n  322      {\n  323          std::ifstream file(filename.c_str());\n  ...\n  408  //#ifdef EDGE_WEIGHT\n  409              //std::cout<<\"defined EDGE_WEIGHT\"<<std::endl;\n  410:             if (costpos > 0 && costpos >= int(_pos_buffer.size()) )\n  411              {\n  412:                 std::cerr<<line_num<<\" wrong costpos position or wrong data line in csv file\\n\";\n  413                  continue;\n  414              }\n  ...\n  453              }\n  454  //#ifdef EDGE_WEIGHT   //new with #define EDGE_WEIGHT  // new    load property data\n  455:             if (costpos > 0)\n  456              {\n  457:                 eit->property().cost = atof(_pos_buffer[costpos].c_str());  // atoi atof   weight-->cost for name\n  458              }\n  459              if (phy_distpos > 0) //new with #define EDGE_WEIGHT  // new\n  ...\n  472  \n  473      long int load_csv_edges_2layer_map(std::string filename, bool has_header, std::string separators,\n  474:                             size_t srcpos, size_t destpos, std::string src_prefix = \"no_prefix\", std::string dest_prefix = \"no_prefix\", bool dag_check=false, bool * loop_ctrl=NULL) //int costpos=-1\n  475      {\n  476          std::ifstream file(filename.c_str());\n\n8 matches in 1 file\n\n\nSearching 1 file for \"costpos\" (regex, whole word)\n\n/Users/renchen/gdrive/code/KSPfirst/openG/openG.h:\n  320      long int load_csv_edges(std::string filename, bool has_header, std::string separators,\n  321                              size_t srcpos, size_t destpos, bool dag_check=false, bool * loop_ctrl=NULL, \n  322:                             size_t max_bw, size_t up_bw_residue, size_t down_bw_residue, int costpos=2, int phy_distpos=3) //int costpos=-1\n  323      {\n  324          std::ifstream file(filename.c_str());\n  ...\n  409  //#ifdef EDGE_WEIGHT\n  410              //std::cout<<\"defined EDGE_WEIGHT\"<<std::endl;\n  411:             if (costpos > 0 && costpos >= int(_pos_buffer.size()) )\n  412              {\n  413:                 std::cerr<<line_num<<\" wrong costpos position or wrong data line in csv file\\n\";\n  414                  continue;\n  415              }\n  ...\n  454              }\n  455  //#ifdef EDGE_WEIGHT   //new with #define EDGE_WEIGHT  // new    load property data\n  456:             if (costpos > 0)\n  457              {\n  458:                 eit->property().cost = atof(_pos_buffer[costpos].c_str());  // atoi atof   weight-->cost for name\n  459              }\n  460              if (phy_distpos > 0) //new with #define EDGE_WEIGHT  // new\n  ...\n  473  \n  474      long int load_csv_edges_2layer_map(std::string filename, bool has_header, std::string separators,\n  475:                             size_t srcpos, size_t destpos, std::string src_prefix = \"no_prefix\", std::string dest_prefix = \"no_prefix\", bool dag_check=false, bool * loop_ctrl=NULL) //int costpos=-1\n  476      {\n  477          std::ifstream file(filename.c_str());\n\n8 matches in 1 file\n\n\nSearching 1 file for \"costpos\" (regex, whole word)\n\n/Users/renchen/gdrive/code/KSPfirst/openG/openG.h:\n  320      long int load_csv_edges(std::string filename, bool has_header, std::string separators,\n  321                              size_t srcpos, size_t destpos, bool dag_check=false, bool * loop_ctrl=NULL, \n  322:                             int mbpos=2, int ubrpos=3, int dbrpos=4, int costpos=5, int phy_distpos=6) //int costpos=-1\n  323      {\n  324          std::ifstream file(filename.c_str());\n  ...\n  424                  continue;\n  425              }\n  426:             if (costpos > 0 && costpos >= int(_pos_buffer.size()) )\n  427              {\n  428:                 std::cerr<<line_num<<\" wrong costpos position or wrong data line in csv file\\n\";\n  429                  continue;\n  430              }\n  ...\n  481                  eit->property().down_bw_residue = atof(_pos_buffer[down_bw_residue].c_str()); \n  482              }\n  483:             if (costpos > 0)\n  484              {\n  485:                 eit->property().cost = atof(_pos_buffer[costpos].c_str());  // atoi atof   weight-->cost for name\n  486              }\n  487              if (phy_distpos > 0) //new with #define EDGE_WEIGHT  // new\n  ...\n  500  \n  501      long int load_csv_edges_2layer_map(std::string filename, bool has_header, std::string separators,\n  502:                             size_t srcpos, size_t destpos, std::string src_prefix = \"no_prefix\", std::string dest_prefix = \"no_prefix\", bool dag_check=false, bool * loop_ctrl=NULL) //int costpos=-1\n  503      {\n  504          std::ifstream file(filename.c_str());\n\n8 matches in 1 file\n\n\nSearching 1 file for \"cost\" (regex, whole word)\n\n/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp.cpp:\n   59  {\n   60  public:\n   61:     edge_property():cost(FLT_MAX),phy_dist(FLT_MAX),max_bw(FLT_MAX),reduced_cost(FLT_MAX){} // new:  Note: \n   62  \n   63:     float cost; // note: here cost means cost\n   64      float phy_dist; //new\n   65      float max_bw;\n   ..\n  209              // min_cost  -- sum_hops    exchange\n  210              unsigned int alt = u_vit->property().sum_hops + 1; // \n  211: \t\t\tfloat alt_cost = u_vit->property().min_cost + eit->property().cost; //  \n  212  \t\t\tunsigned int occur = v_vit->property().occurrence;\n  213  \t\t\t\n  ...\n  220                  v_vit->property().successor = u;  // new, ori is predecessor\n  221                  v_vit->property().sum_hops     = alt; \n  222:                 v_vit->property().min_cost     = u_vit->property().min_cost + eit->property().cost; \n  223                  v_vit->property().sum_distance = u_vit->property().sum_distance + eit->property().phy_dist; \n  224  \t\t\t\tv_vit->property().weight = weight;\n  ...\n  249  \t\t\t\n  250  \t\t\tunsigned int alpha_occur = (v_vit->property().occurrence > 7000) ? int(alpha*10.0) : int(alpha*10.0);\n  251: \t\t\treduced_cost = v_vit->property().min_cost - u_vit->property().min_cost + eit->property().cost + v_vi->property().occurrence*alpha_occur; \n  252              \n  253              eit->property().reduced_cost = reduced_cost;\n  ...\n  339          sssp(g, src, dest, alpha)\n  340  \n  341:     //Compute reduced cost\n  342      if (recompute_g)\n  343          updateReducedCost(g, alpha)\n\n8 matches in 1 file\n\n\nSearching 1 file for \"\nis_loopless_path\" (regex, whole word)\n\n0 matches\n\nSearching 1 file for \"\nis_loopless_path\" (regex, whole word)\n\n<untitled 201>:\n    ERROR: Unable to open file\n\n0 matches\n\nSearching 1 file for \"\nis_loopless_path\" (regex)\n\n0 matches\n\nSearching 1 file for \"graph_t\" (regex)\n\n/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp.cpp:\n   71  };\n   72  \n   73: typedef openG::extGraph<vertex_property, edge_property> graph_t;\n   74: typedef graph_t::vertex_iterator    vertex_iterator;\n   75: typedef graph_t::edge_iterator      edge_iterator;\n   76  \n   77  \n   78: void reset_graph(graph_t & g, bool reset_occurrence)\n   79  {\n   80      vertex_iterator vit;\n   ..\n  136      }\n  137  \n  138:     void output_shorest_path(graph_t& g, size_t src, size_t dest) //for test, src and dest is exID, dest is the input dest of spmc func.\n  139      {\n  140          cout<<\"the shortest path is: \";\n  ...\n  158  \n  159  //Can be optimized using an unordered map\n  160: bool is_loopless_path(graph_t& g, graph_tau& tau, size_t path_last_id_tau, size_t path_first_id_tau)//based on sorted vector\n  161  {\n  162      size_t tmpId = path_last_id_tau;    \n  ...\n  177  \n  178  //calculate the shortest path of any node to internel_dest\n  179: void sssp(graph_t& g,  size_t src, size_t dest, size_t alpha)\n  180  {\n  181      uint64_t internel_src  = g.external_to_internel_id(to_string(src)); \n  ...\n  234  ////(2) reduced_cost computing procedure  -->for edge: update eit->property().reduced_cost\n  235  ////(3) rearrange the arcs\n  236: void updateReducedCost(graph_t& g, size_t alpha)\n  237  {\n  238      for (vertex_iterator u_vit=g.vertices_begin(); u_vit!=g.vertices_end(); u_vit++) // for each vertex u\n  ...\n  262  \n  263  //Return the shortest path for a single src-dest pair\n  264: void getShortestPath(graph_t& g, size_t src, size_t dest, size_t min_bw, vector<size_t> &shorest_path)\n  265  {\n  266      uint64_t internel_src = g.external_to_internel_id(src);\n  ...\n  298  \n  299  //find backup path\n  300: bool findBackupPath(graph_t& g, size_t src, size_t dest, unordered_set<uint64_t>& visited_nodes, stack<size_t> &stack_nodes)\n  301  {\n  302      size_t cur_node = src;\n  ...\n  310  \n  311  //back tracking search\n  312: void backTrackingSearch(graph_t& g, unordered_set<uint64_t>& visited_nodes, size_t src, size_t dest\n  313                         ,size_t min_bw, stack<size_t> &stack_nodes, bool &findPath)\n  314  {\n  ...\n  376  \n  377  //shortest path with multi-constraints\n  378: void spmcSub(ofstream& myfile, graph_t& g, size_t src, size_t dest, size_t min_bw, size_t alpha \\\n  379              ,bool &find_path, vector<size_t> &shortest_path, stack<size_t> &backup_path, bool &recompute_g) // src and dest are exID\n  380  {\n  ...\n  397  \n  398  //spmc: shortest path with multi-constraints\n  399: void spmc(ofstream& myfile, graph_t& g, vector<size_t> &src, vector<size_t> &min_bw, size_t dest,  \\\n  400            gBenchPerf_event & perf, int perf_group)\n  401  {\n  ...\n  503  \n  504  //Initialize a graph\n  505: void graphInit(graph_t &graph, string vfile, string efile, size_t src, size_t dest, string separator)\n  506  {\n  507      cout<<\"loading data... \\n\";\n  ...\n  565  , int max_phy_dist, int max_phy_hops, size_t min_phy_hops,  vector<vector<int> >tests, gBenchPerf_event perf)\n  566  {\n  567:     graph_t *graph;  \n  568      double t1 = timer::get_usec();\n  569      int p_src, p_dest, k_val;\n  ...\n  574      for (unsigned int i=0; i<tests.size(); i++)\n  575      {\n  576:         graph = new graph_t();\n  577          graphInit(*graph, vfile, efile, src, dest, separator);\n  578          p_src = tests[i][0]; \n  ...\n  595  int max_phy_dist, int max_phy_hops, size_t min_phy_hops, vector<vector<int> >tests, gBenchPerf_event perf)\n  596  {\n  597:     graph_t *graph;     \n  598      double t1 = timer::get_usec();\n  599  \n  ...\n  609          res_fstream.open(\"outputSingleLayer/combineMethods_parallel\"+to_string(idx)+\".csv\");\n  610  \n  611:         graph = new graph_t();\n  612          graphInit(*graph, vfile, efile, src, dest, separator);\n  613  \n\n19 matches in 1 file\n\n\nSearching 1 file for \"is_loopless_path\" (regex)\n\n/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp.cpp:\n  158  \n  159  //Can be optimized using an unordered map\n  160: bool is_loopless_path(graph_t& g, graph_tau& tau, size_t path_last_id_tau, size_t path_first_id_tau)//based on sorted vector\n  161  {\n  162      size_t tmpId = path_last_id_tau;    \n\n1 match in 1 file\n\n\nSearching 1 file for \"first\" (regex)\n\n/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp.cpp:\n  111      bool operator()(pair_FltInt a, pair_FltInt b)\n  112      {\n  113:         return a.first > b.first;\n  114      }\n  115  };\n  ...\n  131          for (auto idx = input.cbegin(); idx != input.cend(); ++ idx)\n  132          {\n  133:             cout << \"(\" << idx->first << \",\" << idx->second << \")\" << \",\";\n  134          }\n  135          cout << endl;\n  ...\n  158  \n  159  //Can be optimized using an unordered map\n  160: //bool is_loopless_path(graph_t& g, graph_tau& tau, size_t path_last_id_tau, size_t path_first_id_tau)//based on sorted vector\n  161  //{\n  162  //    size_t tmpId = path_last_id_tau;    \n  ...\n  165  //    vector<size_t> path_id_set_g;  \n  166  //    path_id_set_g.push_back( vit_tau_tmp->property().internel_id_of_g );\n  167: //    while (tmpId != path_first_id_tau)\n  168  //    {\n  169  //        tmpId = vit_tau_tmp->property().predecessor;  \n  ...\n  183      priority_queue<pair_IntFlt, vector<pair_IntFlt>, min_comp_IntFlt> PQ;\n  184  \n  185:     //// Now all processing is based on internel id first.\n  186      //// (1) sssp sub-procedure  -->for vertex: update  v_vit->property().min_cost and v_vit->property().successor \n  187      vertex_iterator dest_vit = g.find_vertex(internel_dest);  // note: here the source of sssp is internel_dest, \n  ...\n  198      while (!PQ.empty())   // sum_distance  sum_hops\n  199      {\n  200:         size_t u = PQ.top().first; //id\n  201          PQ.pop();\n  202  \n  ...\n  280          {\n  281              edge_iterator cur_edge;\n  282:             size_t cur_v_target = *edge_iter.first;\n  283              g.find_out_edge_2id(cur_node, cur_v_target, cur_edge);\n  284  \n  ...\n  344      for(auto v_cost_pair = sorted_edges.begin(); v_cost_pair != sorted_edges.end(); ++v_cost_pair)\n  345      {\n  346:         next_node = *v_cost_pair.first;\n  347          edge_iterator cur_edge_iter;\n  348  \n  ...\n  352  \n  353          //push the next node only if the edge has enough bandwidth\n  354:         if ((visited_nodes.find(*v_cost_pair.first) == visited_nodes.end()) && has_bw)\n  355          {\n  356              stack_nodes.push(next_node);\n\n10 matches in 1 file\n\n\nSearching 1 file for \"stack_nodes\" (regex)\n\n/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp.cpp:\n  300  //back tracking search\n  301  void backTrackingSearch(graph_t& g, unordered_set<uint64_t>& visited_nodes, size_t src, size_t dest\n  302:                        ,size_t min_bw, vector<size_t> &stack_nodes, bool &findPath)\n  303  {\n  304      //Check if tmp_node to dest is another path sharing no edge with shortest path\n  305:     size_t tmp_node = stack_nodes.back();\n  306      bool no_share_nodes = 1;\n  307      bool has_bw = 1;\n  ...\n  337      }\n  338  \n  339:     size_t cur_node = stack_nodes.back();\n  340      size_t next_node;\n  341  \n  ...\n  354          if ((visited_nodes.find(v_cost_pair->first) == visited_nodes.end()) && has_bw)\n  355          {\n  356:             stack_nodes.push_back(next_node);\n  357:             backTrackingSearch(g, visited_nodes, src, dest, min_bw, stack_nodes, findPath);\n  358              if (findPath)\n  359                  return;\n  360:             stack_nodes.pop_back();\n  361          }\n  362      }\n  ...\n  366  \n  367  //find backup path\n  368: bool findBackupPath(graph_t& g, size_t src, size_t dest, size_t min_bw, unordered_set<uint64_t>& visited_nodes, vector<size_t> &stack_nodes)\n  369  {\n  370      size_t cur_node = src;\n  371:     stack_nodes.push_back(cur_node);\n  372      bool find_path = 0;\n  373  \n  374:     backTrackingSearch(g, visited_nodes, src, dest, min_bw, stack_nodes, find_path);\n  375  \n  376      return find_path;\n\n9 matches in 1 file\n",
			"settings":
			{
				"buffer_size": 55670,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 67.0,
		"last_filter": "install pack",
		"selected_items":
		[
			[
				"install pack",
				"Package Control: Install Package"
			]
		],
		"width": 485.0
	},
	"console":
	{
		"height": 153.0,
		"history":
		[
			"--help",
			"help",
			"diff sssp_rc.cpp sssp.cpp"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath"
	],
	"file_history":
	[
		"/Users/renchen/gdrive/code/permutation/verilogGen/gressGen.py",
		"/Users/renchen/gdrive/code/permutation/verilogGen/memGen.py",
		"/Users/renchen/gdrive/code/permutation/verilogGen/perGen.py",
		"/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp_rc_backup.cpp",
		"/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/ksp.cpp",
		"/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp_rc.cpp",
		"/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp.cpp",
		"/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp_backup_parallel.cpp",
		"/Users/renchen/gdrive/code/ksp/source/Graph.cpp",
		"/Users/renchen/gdrive/code/ksp/include/Graph.h",
		"/Users/renchen/gdrive/code/KSPfirst/openG/openG_graph.h",
		"/Users/renchen/code/KSPfirst/openG/openG_graph.h",
		"/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp_backup_serial.cpp",
		"/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp_KSP_looplessAndotherConstraints_bak2.cpp",
		"/Users/renchen/gdrive/2017_aws/connect_aws",
		"/Users/renchen/gdrive/code/KSPfirst/openG/openG.h",
		"/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath/sssp_omp.cpp",
		"/Users/renchen/code/KSPfirst/benchmark/bench_shortestPath/sssp_omp.cpp",
		"/Users/renchen/code/KSPfirst/openG/openG.h",
		"/Users/renchen/code/KSPfirst/benchmark/bench_shortestPath/sssp.cpp"
	],
	"find":
	{
		"height": 35.0
	},
	"find_in_files":
	{
		"height": 93.0,
		"where_history":
		[
			"<current file>",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"p_dest",
			"stack_nodes",
			"first",
			"is_loopless_path",
			"graph_t",
			"\nis_loopless_path",
			"cost",
			"costpos",
			"phy_dist",
			"cost",
			"auto",
			"occurrence",
			"reset_graph",
			"add_partialSP_totau",
			"is_loopless_path",
			"pair_IntFlt",
			"sorted_edges_of_vertex",
			"paths",
			"unordered_set",
			"stack.push_back",
			"stack.push",
			"stack",
			"PQ",
			"adjacent_find",
			"_key2id",
			"spmc_subFun",
			"top_ksp",
			"addr_rom_",
			"counter",
			"name",
			"switches_",
			"wireConStageNames",
			"switchesCtrlNames",
			"genAddrGen",
			"pair",
			"vector",
			"agg_cost",
			"center",
			"[\\n\\r]+",
			"[\\n\\t]+",
			"argument_parser",
			"cout",
			"TOPKSP_PRINTOUT",
			"perf",
			"top_ksp",
			"externel_to_internal_id",
			"externel_to_internel_id",
			"external_to_internal_id",
			"external_to_",
			"graph->",
			"g->",
			"g.",
			"arg_init",
			"graph",
			"vfile",
			"graph",
			"graph_t",
			"graph",
			"internel",
			"threadnum",
			";\n",
			"threadnum",
			"omp"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": true,
		"replace_history":
		[
			"spmc",
			"agg_pairs_cost",
			" ",
			"res_fstream",
			"graph.",
			"g.",
			"g->",
			"internal"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": false
	},
	"folders":
	[
		{
			"path": "/Users/renchen/gdrive/code/KSPfirst/benchmark/bench_shortestPath"
		}
	],
	"groups":
	[
		{
			"selected": 4,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "sssp.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 23580,
						"regions":
						{
						},
						"selection":
						[
							[
								20603,
								20603
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true,
							"word_wrap": true
						},
						"translation.x": 0.0,
						"translation.y": 11712.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "/Users/renchen/gdrive/code/KSPfirst/openG/openG_graph.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 17727,
						"regions":
						{
						},
						"selection":
						[
							[
								14825,
								14893
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 9658.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "/Users/renchen/gdrive/code/KSPfirst/openG/openG_property.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3631,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 269.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "/Users/renchen/gdrive/code/KSPfirst/openG/openG_storage.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8447,
						"regions":
						{
						},
						"selection":
						[
							[
								280,
								280
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 5989.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "/Users/renchen/gdrive/code/KSPfirst/openG/openG.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 27269,
						"regions":
						{
						},
						"selection":
						[
							[
								15640,
								15640
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 8479.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		},
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 5,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 55670,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										264,
										271
									],
									[
										372,
										379
									],
									[
										719,
										726
									],
									[
										1045,
										1052
									],
									[
										1395,
										1402
									],
									[
										1715,
										1722
									],
									[
										1977,
										1984
									],
									[
										2339,
										2346
									],
									[
										2484,
										2491
									],
									[
										2728,
										2735
									],
									[
										2961,
										2968
									],
									[
										2986,
										2993
									],
									[
										3110,
										3117
									],
									[
										3384,
										3391
									],
									[
										3716,
										3723
									],
									[
										3741,
										3748
									],
									[
										3865,
										3872
									],
									[
										4107,
										4114
									],
									[
										4160,
										4167
									],
									[
										4286,
										4293
									],
									[
										4410,
										4417
									],
									[
										4527,
										4534
									],
									[
										4606,
										4613
									],
									[
										4730,
										4737
									],
									[
										4849,
										4856
									],
									[
										5040,
										5047
									],
									[
										5093,
										5100
									],
									[
										5219,
										5226
									],
									[
										5343,
										5350
									],
									[
										5460,
										5467
									],
									[
										5539,
										5546
									],
									[
										5663,
										5670
									],
									[
										5782,
										5789
									],
									[
										6005,
										6012
									],
									[
										6171,
										6178
									],
									[
										6539,
										6552
									],
									[
										7030,
										7032
									],
									[
										7239,
										7241
									],
									[
										7544,
										7546
									],
									[
										7623,
										7625
									],
									[
										7659,
										7661
									],
									[
										7980,
										7982
									],
									[
										8148,
										8150
									],
									[
										8393,
										8395
									],
									[
										8791,
										8793
									],
									[
										9242,
										9244
									],
									[
										9408,
										9410
									],
									[
										9498,
										9500
									],
									[
										9754,
										9756
									],
									[
										10179,
										10181
									],
									[
										10375,
										10377
									],
									[
										11185,
										11187
									],
									[
										11394,
										11396
									],
									[
										11699,
										11701
									],
									[
										11778,
										11780
									],
									[
										11814,
										11816
									],
									[
										12135,
										12137
									],
									[
										12303,
										12305
									],
									[
										12548,
										12550
									],
									[
										12946,
										12948
									],
									[
										13397,
										13399
									],
									[
										13563,
										13565
									],
									[
										13653,
										13655
									],
									[
										13909,
										13911
									],
									[
										14334,
										14336
									],
									[
										14530,
										14532
									],
									[
										14863,
										14876
									],
									[
										15185,
										15198
									],
									[
										15420,
										15433
									],
									[
										15678,
										15691
									],
									[
										15913,
										15926
									],
									[
										16465,
										16478
									],
									[
										16768,
										16781
									],
									[
										17080,
										17085
									],
									[
										17279,
										17284
									],
									[
										17317,
										17322
									],
									[
										17640,
										17645
									],
									[
										18102,
										18107
									],
									[
										18362,
										18367
									],
									[
										18607,
										18612
									],
									[
										18649,
										18654
									],
									[
										18957,
										18962
									],
									[
										18976,
										18981
									],
									[
										19028,
										19033
									],
									[
										19128,
										19133
									],
									[
										19448,
										19453
									],
									[
										19592,
										19597
									],
									[
										19841,
										19846
									],
									[
										19978,
										19983
									],
									[
										20264,
										20269
									],
									[
										20516,
										20521
									],
									[
										20559,
										20564
									],
									[
										21042,
										21047
									],
									[
										21100,
										21105
									],
									[
										21298,
										21303
									],
									[
										21424,
										21429
									],
									[
										21622,
										21627
									],
									[
										21801,
										21806
									],
									[
										21944,
										21949
									],
									[
										22037,
										22042
									],
									[
										22217,
										22222
									],
									[
										22449,
										22454
									],
									[
										22529,
										22534
									],
									[
										22866,
										22871
									],
									[
										23157,
										23179
									],
									[
										23365,
										23387
									],
									[
										23651,
										23673
									],
									[
										23809,
										23831
									],
									[
										23859,
										23881
									],
									[
										24323,
										24345
									],
									[
										24574,
										24585
									],
									[
										24621,
										24632
									],
									[
										24718,
										24729
									],
									[
										24816,
										24827
									],
									[
										24956,
										24967
									],
									[
										25105,
										25116
									],
									[
										25120,
										25131
									],
									[
										25384,
										25395
									],
									[
										25404,
										25415
									],
									[
										25636,
										25647
									],
									[
										26047,
										26058
									],
									[
										26215,
										26226
									],
									[
										26446,
										26457
									],
									[
										26673,
										26684
									],
									[
										26697,
										26708
									],
									[
										26934,
										26945
									],
									[
										27348,
										27359
									],
									[
										27656,
										27672
									],
									[
										28061,
										28077
									],
									[
										28279,
										28295
									],
									[
										28451,
										28467
									],
									[
										28820,
										28836
									],
									[
										29188,
										29207
									],
									[
										29538,
										29549
									],
									[
										29690,
										29701
									],
									[
										30150,
										30160
									],
									[
										30426,
										30436
									],
									[
										30696,
										30706
									],
									[
										30933,
										30943
									],
									[
										30967,
										30977
									],
									[
										31263,
										31273
									],
									[
										31708,
										31718
									],
									[
										31800,
										31810
									],
									[
										31979,
										31989
									],
									[
										32281,
										32291
									],
									[
										32592,
										32596
									],
									[
										32812,
										32816
									],
									[
										33140,
										33144
									],
									[
										33373,
										33377
									],
									[
										33674,
										33678
									],
									[
										33823,
										33827
									],
									[
										34155,
										34159
									],
									[
										34235,
										34239
									],
									[
										34275,
										34279
									],
									[
										34332,
										34336
									],
									[
										34352,
										34356
									],
									[
										34363,
										34367
									],
									[
										34455,
										34459
									],
									[
										34608,
										34612
									],
									[
										34926,
										34930
									],
									[
										35137,
										35141
									],
									[
										35332,
										35336
									],
									[
										35559,
										35563
									],
									[
										35683,
										35687
									],
									[
										35712,
										35716
									],
									[
										35735,
										35739
									],
									[
										35951,
										35955
									],
									[
										36245,
										36249
									],
									[
										36278,
										36282
									],
									[
										36301,
										36305
									],
									[
										36515,
										36519
									],
									[
										36585,
										36589
									],
									[
										36649,
										36653
									],
									[
										36910,
										36914
									],
									[
										36965,
										36969
									],
									[
										37041,
										37045
									],
									[
										37200,
										37204
									],
									[
										37226,
										37230
									],
									[
										37433,
										37437
									],
									[
										37462,
										37466
									],
									[
										37491,
										37495
									],
									[
										37514,
										37518
									],
									[
										37626,
										37630
									],
									[
										37641,
										37645
									],
									[
										37739,
										37743
									],
									[
										37782,
										37786
									],
									[
										38102,
										38106
									],
									[
										38138,
										38142
									],
									[
										38175,
										38179
									],
									[
										38239,
										38243
									],
									[
										38335,
										38339
									],
									[
										38557,
										38561
									],
									[
										38618,
										38622
									],
									[
										38872,
										38876
									],
									[
										38969,
										38973
									],
									[
										38989,
										38993
									],
									[
										39000,
										39004
									],
									[
										39267,
										39271
									],
									[
										39603,
										39607
									],
									[
										40000,
										40004
									],
									[
										40217,
										40221
									],
									[
										40559,
										40567
									],
									[
										41088,
										41095
									],
									[
										41124,
										41131
									],
									[
										41324,
										41331
									],
									[
										41339,
										41346
									],
									[
										41449,
										41456
									],
									[
										41696,
										41703
									],
									[
										41793,
										41800
									],
									[
										42268,
										42275
									],
									[
										42781,
										42788
									],
									[
										42817,
										42824
									],
									[
										43017,
										43024
									],
									[
										43032,
										43039
									],
									[
										43142,
										43149
									],
									[
										43389,
										43396
									],
									[
										43486,
										43493
									],
									[
										43961,
										43968
									],
									[
										44454,
										44461
									],
									[
										44490,
										44497
									],
									[
										44650,
										44657
									],
									[
										44665,
										44672
									],
									[
										44775,
										44782
									],
									[
										45033,
										45040
									],
									[
										45130,
										45137
									],
									[
										45605,
										45612
									],
									[
										45880,
										45884
									],
									[
										45993,
										45997
									],
									[
										46013,
										46017
									],
									[
										46024,
										46028
									],
									[
										46295,
										46299
									],
									[
										46631,
										46635
									],
									[
										47028,
										47032
									],
									[
										47245,
										47249
									],
									[
										47795,
										47802
									],
									[
										47819,
										47826
									],
									[
										47879,
										47886
									],
									[
										47962,
										47969
									],
									[
										48102,
										48109
									],
									[
										48362,
										48369
									],
									[
										48374,
										48381
									],
									[
										48619,
										48626
									],
									[
										48928,
										48935
									],
									[
										49179,
										49186
									],
									[
										49404,
										49411
									],
									[
										49627,
										49634
									],
									[
										49900,
										49907
									],
									[
										50217,
										50224
									],
									[
										50421,
										50428
									],
									[
										50699,
										50706
									],
									[
										50897,
										50904
									],
									[
										51155,
										51162
									],
									[
										51367,
										51374
									],
									[
										51673,
										51689
									],
									[
										52078,
										52083
									],
									[
										52088,
										52093
									],
									[
										52256,
										52261
									],
									[
										52504,
										52509
									],
									[
										52770,
										52775
									],
									[
										53017,
										53022
									],
									[
										53381,
										53386
									],
									[
										53544,
										53549
									],
									[
										53798,
										53803
									],
									[
										53997,
										54002
									],
									[
										54446,
										54457
									],
									[
										54603,
										54614
									],
									[
										54743,
										54754
									],
									[
										54936,
										54947
									],
									[
										55045,
										55056
									],
									[
										55152,
										55163
									],
									[
										55381,
										55392
									],
									[
										55448,
										55459
									],
									[
										55587,
										55598
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								54128,
								54128
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"line_numbers": false,
							"output_tag": 32,
							"result_base_dir": "",
							"result_file_regex": "^([^ \t].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 25043.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 27.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				0,
				1,
				1,
				2
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			0.713553223619,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "",
	"replace":
	{
		"height": 64.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 202.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
